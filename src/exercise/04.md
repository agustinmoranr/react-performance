# Window large lists with react-virtual

## üìù Tus notas

A√±ade tus anotaciones aqu√≠ `src/exercise/04.md`

> NOTE: We're going to be using a library called `react-virtual`. Some of you
> may have used this before and others may not have used it or anything else
> like it. I normally like to build up to abstractions like this one by building
> a simple version of the abstraction ourselves, but that would be a workshop
> entirely to itself! Implementing this is nontrivial, so try to focus on the
> concepts even though we're using a library.

## Background

As we learned in the last exercise, React is really optimized at updating the
DOM during the commit phase.

Como ya vimos en el ejercicio anteior, la actualizaci√≥n del DOM de React esta
muy optimizada durante la fase de commit

Desafortunadamente, no hay mucho que React pueda hacer si lo que necesitas es
hacer una **gran** actualizaci√≥n del DOM. y tan rapido como react alcanza la
fase de reconcilaci√≥n, si lo tiene que hacer para miles de elementos, sin duda
le tomar√° algo de tiempo ("perf death by a thousand cuts"). En adici√≥n, nuestro
c√≥digo que se ejecuta durante la fase de "renderizado" deber√≠a ser r√°pida, pero
si tienes que hacer eso miles de veces, tendr√°s problemas tratando de ser r√°pido
en dispositivos con poco poder de hardware.

Unfortunately, there's not much React can do if you simply need to make **huge**
updates to the DOM. And as fast as React is in the reconciliation phase, if it
has to do that for tens of thousands of elements that's going to take some time
("perf death by a thousand cuts"). In addition, our own code that runs during
the "render" phase may be fast, but if you have to do that tens of thousands of
times, you're going to have a hard time being fast on low-end devices.

Los elementos de UI que mas muestran estos problemas son graficos de
visualizaci√≥n de datos, grids, tablas y listas con muchos datos de informaci√≥n.
Hay mucho que se puede hacer antes de que tengamos que concluir que simplemente
estamos ejecutando demasiado c√≥digo (o ejecutando la misma peque√±a cantidad de
c√≥digo demasiadas veces).

There's no UI that reveals these problems more than dataviz, grids, tables, and
lists with lots of data. There's only so much you can do before we have to
conclude that we're simply running too much code (or running the same small
amount of code too many times).

Pero aqu√≠ esta el truco. Comunmente no necesitas realmente mostrar miles de
items de una lista, celdas de tablas o puntos de datos a los usuarios. Por lo
que si no se esta mostrando ese contenido, entonces puedes realizar un
renderizado "en el momento" √≥ "lazy"

But here's the trick. Often you don't need to actually display tens of thousands
of list items, table cells, or data points to users. So if that content isn't
displayed, then you can kinda cheat by doing some "lazy" just-in-time rendering.

Digamos que que tienes una grilla de datos que renderiza 100 columns y tiene
5000 filas. Realmente necesitas renderizar esas 500000 celdas al mismo tiempo
para el usuario? Ellos ciertamente no veran o ser√°n capaces de interactuar con
toda esa informaci√≥n. Posiblemente solo mostrar√°s una ventana con 10 columnas y
20 filas, y de el resto, puedes retrasar el renderizado hasta que el usuario
haga scroll en la grilla/tabla.

So let's say you had a grid of data that rendered 100 columns and had 5000 rows.
Do you really need to render all 500000 cells for the user all at once? They
certainly won't see or be able to interact with all of that information at once.
You'll only display a "window" of 10 columns by 20 rows (so 200 cells for
example), and the rest you can delay rendering until the user starts scrolling
around the grid.

Tal vez puedas representar algunas celdas fuera de la vista en caso de que el
usuario haga scroll muy r√°pido. En cualquier caso, se ahorrar√° MUCHA potencia
computacional al hacer este renderizado "lazy" justo a tiempo.

Maybe you can render a few cells outside the view just in case they're a really
fast scroller. In any case, you'll save yourself a LOT of computational power by
doing this "lazy" just-in-time rendering.

Este es un concepto llamado "windowing" y en algunos casos realmente puede
acelerar tus componentes que renderizan mucha informaci√≥n. Hay varias librarias
en el ecosistema de React para solventar este problema. una de ellas de
react-virtual. Aqu√≠ un ejemplo de como adaptar una lista para utilizar el hook
useVirtual:

This is a concept called "windowing" and in some cases it can really speed up
your components that render lots of data. There are various libraries in the
React ecosystem for solving this problem. My personal favorite is called
`react-virtual`. Here's an example of how you would adapt a list to use
`react-virtual`'s `useVirtual` hook:

```jsx
// antes
function MyListOfData({items}) {
  return (
    <ul style={{height: 300}}>
      {items.map(item => (
        <li key={item.id}>{item.name}</li>
      ))}
    </ul>
  )
}
```

```jsx
// despu√©s
function MyListOfData({items}) {
  const listRef = React.useRef()
  const rowVirtualizer = useVirtual({
    size: items.length,
    parentRef: listRef,
    estimateSize: React.useCallback(() => 20, []),
    overscan: 10,
  })

  return (
    <ul ref={listRef} style={{position: 'relative', height: 300}}>
      <li style={{height: rowVirtualizer.totalSize}} />
      {rowVirtualizer.virtualItems.map(({index, size, start}) => {
        const item = items[index]
        return (
          <li
            key={item.id}
            style={{
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100%',
              height: size,
              transform: `translateY(${start}px)`,
            }}
          >
            {item.name}
          </li>
        )
      })}
    </ul>
  )
}
```

En resumen, en lugar de iterar sobre todos los elementos en su lista,
simplemente le dices a `useVirtual` cu√°ntas filas hay en su lista, y con un
callback que le indique cual ser√≠a el tama√±o estimado del elemento, y este
retornar√° las propiedades `virtualItems` y un `totalSize` que luego puedes usar
para renderizar solo los elementos que el usuario deber√≠a poder ver dentro de la
ventana.

In summary, rather than iterating over all the items in your list, you simply
tell `useVirtual` how many rows are in your list, give it a callback that it can
use to determine what size they each should be, and then it will give you back
`virtualItems` and a `totalSize` which you can then use to only render the items
the user should be able to see within the window.

[react-virtual](https://github.com/tannerlinsley/react-virtual) has some really
awesome capabilities for all sorts of lists (including variable sizes and
grids). Definitely give it a look to speed up your lists.

## Exercise

Production deploys:

- [Exercise](https://react-performance.netlify.app/isolated/exercise/04.js)
- [Final](https://react-performance.netlify.app/isolated/final/04.js)

üë®‚Äçüíº The product manager noticed that we're only rendering the top 100 matches and
they're frustrated because they like scrolling for eternity. We tried to explain
to them about React's reconciliation and commit phases, but they just smiled,
gave us a high five and said "You're smart! I'm sure you can do this!"

So in this exercise, we've removed the `items.slice(0, 100)` and now we're
rendering all the items. Even without throttling your CPU, you should notice a
serious performance problem here any time there's any render of any kind. Go
ahead and try doing some profiling if you like, but I think you know what you
need to do. You need to window this stuff! Run less code, and speed up your
component.

Note that üí∞ Marty the Money Bag has done a tiny bit of work for you that's
specific to how you integrate Downshift and react-virtual. He's done a good job
documenting what he's done so you can read about the changes he made if you
want. üê® Kody the Koala will be there to help you know what changes you need to
make. Good luck!

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Performance%20%E2%9A%A1&e=04%3A%20Window%20large%20lists%20with%20react-virtual&em=).
