# Code splitting

## üìù Your Notes

Escribe tus anotaciones aqu√≠ `src/exercise/01.md`

## Background

El Code splitting act√∫a seg√∫n el principio de que cargar menos c√≥digo acelerar√°
su aplicaci√≥n. Digamos, por ejemplo, que estamos creando una aplicaci√≥n de
dashboards compleja que incluye una biblioteca d3 para graficar datos. Sus
usuarios comienzan a quejarse porque la pantalla de inicio de sesi√≥n tarda
demasiado en cargarse.

Entonces, considerando que los problemas de rendimiento se pueden resolver con
menos c√≥digo, ¬øc√≥mo podemos resolver este? Bueno, ¬ørealmente _necesitamos_ tener
ese c√≥digo para el gr√°fico cuando el usuario carga la pantalla de inicio de
sesi√≥n? ¬°No! Podr√≠amos cargar eso on-demand.

Afortunadamente para nosotros, hay una forma integrada de hacer esto con los
est√°ndares de JavaScript. Se llama importaci√≥n din√°mica y la sintaxis se ve as√≠:

```javascript
import('/some-module.js').then(
  module => {
    // hacer cosas con las exportaciones del m√≥dulo
  },
  error => {
    // hubo alg√∫n error al cargar el m√≥dulo...
  },
)
```

> üìú Aprende m√°s sobre imports din√°micos en el navegador en
> [Super Simple Start to ESModules in the browser](https://kentcdodds.com/blog/super-simple-start-to-es-modules-in-the-browser)

Para llevar esto m√°s lejos, React tiene soporte incorporado para cargar m√≥dulos
como componentes de React. El modulo debe exportar por default un componente de
React, y tienes que utilizar el component `<React.Suspense />` para renderizar
un valor de fallback mientras el usuario espera a que se cargue el modulo.

```javascript
// smiley-face.js
import * as React from 'react'

function SmileyFace() {
  return <div>üòÉ</div>
}

export default SmileyFace

// app.js
import * as React from 'react'

const SmileyFace = React.lazy(() => import('./smiley-face'))

function App() {
  return (
    <div>
      <React.Suspense fallback={<div>loading...</div>}>
        <SmileyFace />
      </React.Suspense>
    </div>
  )
}
```

ü¶â Una buena forma de analizar tu app para determinar la necesidad/beneficio del
code splitting para una caracter√≠stica especifica es
[la caracter√≠stica "Coverage" en los developer tools](https://developers.google.com/web/tools/chrome-devtools/coverage).

## Ejercicio

Despliegues productivos:

- [Ejercicio](https://react-performance.netlify.app/isolated/exercise/01.js)
- [Final](https://react-performance.netlify.app/isolated/final/01.js)

Nuestra aplicaci√≥n tiene un elegante componente Globe que muestra al usuario
d√≥nde se encuentra en el mundo. ¬øCool, verdad? Es s√∫per divertido.

Pero un d√≠a, nuestro product manager üë®‚Äçüíº apareci√≥ y dijo que los usuarios se
quejan de que la aplicaci√≥n tarda demasiado en cargarse. Estamos usando varias
bibliotecas importantes para tener un globo terr√°queo realmente genial, pero los
usuarios solo necesitan cargarlo si hacen clic en el bot√≥n "mostrar globo
terr√°queo" y cargarlo con anticipaci√≥n hace que la aplicaci√≥n se cargue m√°s
lentamente.

Por lo tanto, tu trabajo como profesional del rendimiento es cargar el c√≥digo
on-demand para que el usuario no tenga que esperar para ver la casilla de
verificaci√≥n.

Para esto, deber√°s abrir la versi√≥n final de forma aislada y abrir la pesta√±a
Red de Chrome DevTools para ver c√≥mo se cargan los chunks de webpack cuando
haces clic en "mostrar globo". Tu objetivo es que la red cargue esos mismos
chunks para que no esten durante la carga inicial.

üí∞ Aqu√≠ hay un consejo r√°pido: en la pesta√±a Red, hay un men√∫ desplegable para
acelerar artificialmente la velocidad de su red. El valor predeterminado es "No
throttling", pero puede cambiarlo a "3G fast", "3G slow", etc.

Tambi√©n, invierte algo de tiempo jugando con la caracter√≠stica de coverage del
chrome devtools

ü¶â Tambi√©n puede intentar ejecutar el build productivo para que pueda ver c√≥mo
son los tama√±os post-minification: ejecute `npm run build` y luego
`npm run serve`.

ü¶â Tambi√©n es posible que quieras utilizar el modo de inc√≥gnito para que los
complementos del navegador no interfieran con la experiencia t√≠pica del usuario.

## Extra Credit

### 1. üíØ eager loading

[Desliegue productivo](https://react-performance.netlify.app/isolated/final/01.extra-1.js)

Es genial que los usuarios puedan cargar la aplicaci√≥n m√°s r√°pido, pero es
molesto cuando el 99 % de las veces la raz√≥n por la que los usuarios usan la
aplicaci√≥n es para poder interactuar con nuestro componente Globe. No queremos
tener que hacerlos esperar primero para cargar la aplicaci√≥n y luego otra vez
para cargar el globo. ¬øNo ser√≠a genial si pudi√©ramos hacer que el globo comience
a cargarse tan pronto como el usuario pasa el cursor sobre la casilla de
verificaci√≥n? Entonces, si utilizando los eventos `mouseOver` o `focus` sobre el
`<label>` de la casilla de verificaci√≥n, deber√≠amos iniciar un dinamic import
para el m√≥dulo de Globe.

A ver si puedes hacer que eso funcione.

> üí∞ Pista: no importa cuantas veces llames `import('./path-to-module')`,
> webpack solo cargar√° el m√≥dulo una vez.

### 2. üíØ webpack magic comments

[Despliegue productivo](https://react-performance.netlify.app/isolated/final/01.extra-2.js)

Si est√° utilizando weback para generar el bundle de tu aplicaci√≥n, entonces
puedes usar webpack
[magic comments](https://webpack.js.org/api/module-methods/#magic-comments) para
que webpack le indique al navegador que busque previamente las importaciones
din√°micas:

```javascript
import(/* webpackPrefetch: true */ './some-module.js')
```

Cuando webpack detecta este comentario, a√±ade esto al `head` de tu html

```javascript
<link rel="prefetch" as="script" href="/static/js/1.chunk.js">
```

Con esto, el navegador cargar√° autom√°ticamente este archivo JavaScript en el
cach√© del navegador para que est√© listo con anticipaci√≥n.

El cambio en s√≠ es m√≠nimo, pero abra DevTools para asegurarse de que se cargue
correctamente (deber√° desmarcar el bot√≥n "Desactivar cach√©" para observar
cualquier cambio).

## Notas

Otra cosa que no cubriremos en este workshop, pero que deber√≠as analizar m√°s
adelante, es usar el magic comment `webpackChunkName` que permitir√° que webpack
coloque m√≥dulos comunes en el mismo chunk. Esto es bueno para los componentes
que desea cargar juntos en el mismo fragmento (para reducir las solicitudes
m√∫ltiples de m√≥dulos m√∫ltiples que probablemente se necesitar√°n juntos).

Pudes jugar con esta funcionalidad en la carpeta `src/examples/code-splitting`.

## ü¶â Feedback

Fill out
[the feedback form](https://ws.kcd.im/?ws=React%20Performance%20%E2%9A%A1&e=01%3A%20Code%20splitting&em=agustin.moranr%40gmail.com).
